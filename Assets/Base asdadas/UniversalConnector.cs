using UnityEngine;
using System.Linq;

/// <summary>
/// ????????????? ????????? ??? ?????????? ???????????? ????????.
/// ????????? ??????? ?? ?????? ? ??????????? ?????? ? ?????????? ????? ?? SnapPointHolder.
/// </summary>
public class UniversalConnector : MonoBehaviour
{
    // ????????? ??? ???????? ?????????? ? ????????? ??????????
    private class SnapCandidate
    {
        public SnapPoint TargetSnap;
        public SnapPoint MovingSnap;
        public float Distance;
        public int Rank; // ???? ?????????????
    }

    public bool Connect(RaycastHit hit)
    {
        if (hit.collider == null)
        {
            return false;
        }

        var targetHolder = hit.transform.GetComponent<SnapPointHolder>();
        var movingHolder = GetComponent<SnapPointHolder>();
        
        if (targetHolder == null || movingHolder == null)
        {
            return false;
        }

        var candidates = FindSnapCandidates(movingHolder, targetHolder, hit);
        if (candidates.Count == 0)
        {
            return false;
        }

        var bestCandidate = FindBestCandidate(candidates);
        if (bestCandidate == null)
        {
            return false;
        }

        ApplySnapTransform(bestCandidate, hit.transform);
        
        // --- NEW: Register neighbors after successful snap ---
        RegisterNeighbors(hit.transform);
        
        return true;
    }

    private void RegisterNeighbors(Transform targetTransform)
    {
        var movingHealth = GetComponent<ConstructionHealth>();
        var targetHealth = targetTransform.GetComponent<ConstructionHealth>();

        if (movingHealth != null && targetHealth != null)
        {
            if (!movingHealth.neighbors.Contains(targetHealth))
            {
                movingHealth.neighbors.Add(targetHealth);
                Debug.Log($"[Connector] Added {targetHealth.gameObject.name} to {movingHealth.gameObject.name}'s neighbors.");
            }
            if (!targetHealth.neighbors.Contains(movingHealth))
            {
                targetHealth.neighbors.Add(movingHealth);
                Debug.Log($"[Connector] Added {movingHealth.gameObject.name} to {targetHealth.gameObject.name}'s neighbors.");
            }
        }
    }

    private System.Collections.Generic.List<SnapCandidate> FindSnapCandidates(SnapPointHolder movingHolder, SnapPointHolder targetHolder, RaycastHit hit)
    {
        var candidates = new System.Collections.Generic.List<SnapCandidate>();
        
        // 1. ????? ??? ????????? ??????? ?????
        var validTargetSnaps = targetHolder.snapPoints
            .Where(p => p.allowedNeighborTags.Contains(gameObject.tag));

        // 2. ??? ?????? ??????? ????? ????? ?????? ???????? ????? ?? ??????? ???????
        foreach (var targetSnap in validTargetSnaps)
        {
            SnapPoint bestMovingSnap = null;
            int bestRank = 0;

            // ???? ?????? ???????? ????? ?? ??????? (????????????) ???????
            foreach (var movingSnap in movingHolder.snapPoints)
            {
                // ?????????, ????????? ?? ??????? ????? ?????????? ? ????? ???????? ???????
                if (movingSnap.allowedNeighborTags.Contains(hit.transform.tag))
                {
                    int currentRank = GetCompatibilityRank(movingSnap, targetSnap, hit.transform.tag);
                    if (currentRank > bestRank)
                    {
                        bestRank = currentRank;
                        bestMovingSnap = movingSnap;
                    }
                }
            }

            if (bestMovingSnap != null)
            {
                candidates.Add(new SnapCandidate
                {
                    TargetSnap = targetSnap,
                    MovingSnap = bestMovingSnap,
                    Rank = bestRank,
                    Distance = Vector3.Distance(hit.point, hit.transform.TransformPoint(targetSnap.localPosition))
                });
            }
        }
        
        return candidates;
    }

    private SnapCandidate FindBestCandidate(System.Collections.Generic.List<SnapCandidate> candidates)
    {
        // ??????? ??????? ?????????: ??????? ?? ?????, ????? ?? ?????????
        return candidates
            .OrderByDescending(c => c.Rank)
            .ThenBy(c => c.Distance)
            .FirstOrDefault();
    }

    private void ApplySnapTransform(SnapCandidate candidate, Transform targetTransform)
    {
        // ????????? ?????????????
        Transform t = targetTransform;
        Vector3 targetWorldPos = t.TransformPoint(candidate.TargetSnap.localPosition);
        Quaternion targetWorldRot = t.rotation * candidate.TargetSnap.LocalRotation;
        
        // ?????????? ??? ?????????? ??? ??????????? ??????? ????????
        string movingType = GetSnapType(candidate.MovingSnap.id);
        string targetType = GetSnapType(candidate.TargetSnap.id);
        
        Quaternion desiredMovingWorldRot;
        
        // ???? ??? ???????????? ?????????? (Face ? Edge ??? ????????)
        if ((movingType == "Face" && targetType == "Edge") || (movingType == "Edge" && targetType == "Face"))
        {
            // ??? ???????????? ?????????? ????????? ??????????? ??????? ?????
            // ? ???????????? ?????? ??????????????? ? ????
            Vector3 targetDirection = GetEdgeDirection(candidate.TargetSnap.id);
            Vector3 worldTargetDirection = t.rotation * targetDirection;
            
            // ????? ?????? ?????? ??????????????? ? ???? ??????????
            desiredMovingWorldRot = Quaternion.LookRotation(worldTargetDirection, Vector3.up);
        }
        else
        {
            // ??? ?????????????? ?????????? (Edge ? Edge) ????????? ??????? ?? 180?
            desiredMovingWorldRot = targetWorldRot * Quaternion.Euler(0, 180f, 0);
        }
        
        // ????????????? ??????? ????? ???????
        // ??? ???????????? ?????????? ?? ????????? Inverse ?? ????? ????????
        if ((movingType == "Face" && targetType == "Edge") || (movingType == "Edge" && targetType == "Face"))
        {
            transform.rotation = desiredMovingWorldRot;
        }
        else
        {
            transform.rotation = desiredMovingWorldRot * Quaternion.Inverse(candidate.MovingSnap.LocalRotation);
        }
        
        // ????????????? ??????? ???, ????? ???? ????? ????????? ????? ? ??????? ??????? ?????
        Vector3 movingSnapWorldPos = transform.TransformPoint(candidate.MovingSnap.localPosition);
        transform.position += targetWorldPos - movingSnapWorldPos;
    }

    /// <summary>
    /// ?????????? ???? ????????????? ???? ?????. ??? ???? ????, ??? ????? ??????????.
    /// </summary>
    private int GetCompatibilityRank(SnapPoint movingSnap, SnapPoint targetSnap, string targetTag)
    {
        if (!movingSnap.allowedNeighborTags.Contains(targetTag))
        {
            return 0;
        }

        string movingId = movingSnap.id;
        string targetId = targetSnap.id;

        // ???? 3: ????????? ??????????????? ?????????? (Edge_Top_X+ <-> Edge_Bottom_X-)
        string oppositeId = GetOppositeId(targetId);
        if (movingId == oppositeId)
        {
            return 3;
        }

        // ???? 2: ?????????? ????????? ? ????? (Face_Bottom <-> Edge_Top_X+)
        if (movingId.Contains("Face_Bottom") && targetId.Contains("Edge_Top"))
        {
            return 2;
        }
        if (movingId.Contains("Face_Top") && targetId.Contains("Edge_Bottom"))
        {
            return 2;
        }
        // ????? ???????? ??????????? ??????? ??? ???? ? ?????? ? ?.?.

        // ???? 1: ??????? ?????????? ?? ???? (???? ?????? ?????? ?? ???????)
        return 1;
    }

    /// <summary>
    /// ?????????? "???????????????" ID ??? ?????.
    /// </summary>
    private string GetOppositeId(string id)
    {
        id = id.Replace("Top", "temp").Replace("Bottom", "Top").Replace("temp", "Bottom");
        id = id.Replace("X+", "temp").Replace("X-", "X+").Replace("temp", "X-");
        id = id.Replace("Z+", "temp").Replace("Z-", "Z+").Replace("temp", "Z-");
        return id;
    }

    /// <summary>
    /// ?????????? ??? ????? ???????? (Face, Edge, Corner)
    /// </summary>
    private string GetSnapType(string snapId)
    {
        if (snapId.Contains("Face")) return "Face";
        if (snapId.Contains("Edge")) return "Edge";
        if (snapId.Contains("Corner")) return "Corner";
        return "Unknown";
    }

    /// <summary>
    /// ???????? ??????????? ???? ??? ???????????? ??????????
    /// </summary>
    private Vector3 GetEdgeDirection(string snapId)
    {
        // ????????????, ??? ??????????? ???? ???????? ? ???? ??????? ? ID
        // ????????, "Edge_X+_Z-" -> ??????????? (1, 0, -1)
        
        Vector3 direction = Vector3.zero;
        
        if (snapId.Contains("X+")) direction.x = 1;
        if (snapId.Contains("X-")) direction.x = -1;
        if (snapId.Contains("Z+")) direction.z = 1;
        if (snapId.Contains("Z-")) direction.z = -1;
        
        direction.Normalize();
        return direction;
    }
}
