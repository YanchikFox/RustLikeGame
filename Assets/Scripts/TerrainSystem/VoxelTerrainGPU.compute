// VoxelTerrainGPU.compute
// GPU-based voxel terrain generation and modification

#pragma kernel GenerateVoxelData
#pragma kernel MarchingCubes
#pragma kernel ModifyDensity

RWStructuredBuffer<float> _DensityValues;
float3 _ChunkWorldOrigin;
int3 _ChunkSize;
float _VoxelSize;
int _LODLevel;

float _BiomeNoiseScale;
float _BiomeBlendRange;
int _BiomeCount;
StructuredBuffer<float> _BiomeThresholds;
StructuredBuffer<float> _BiomeGroundLevels;
StructuredBuffer<float> _BiomeHeightImpacts;
StructuredBuffer<float> _BiomeHeightScales;
StructuredBuffer<float> _BiomeCaveImpacts;
StructuredBuffer<float> _BiomeCaveScales;
StructuredBuffer<int>   _BiomeOctaves;
StructuredBuffer<float> _BiomeLacunarity;
StructuredBuffer<float> _BiomePersistence;
StructuredBuffer<int>   _BiomeHeightWarpEnabled;
StructuredBuffer<float> _BiomeHeightWarpStrengths;
StructuredBuffer<float> _BiomeHeightWarpScales;
StructuredBuffer<int>   _BiomeHeightWarpRidged;
StructuredBuffer<int>   _BiomeSecondaryHeightWarpEnabled;
StructuredBuffer<float> _BiomeSecondaryHeightWarpStrengths;
StructuredBuffer<float> _BiomeSecondaryHeightWarpScales;
StructuredBuffer<int>   _BiomeSecondaryHeightWarpRidged;
StructuredBuffer<int>   _BiomeCaveWarpEnabled;
StructuredBuffer<float> _BiomeCaveWarpStrengths;
StructuredBuffer<float> _BiomeCaveWarpScales;
StructuredBuffer<int>   _BiomeCaveWarpRidged;
StructuredBuffer<int>   _BiomeSecondaryCaveWarpEnabled;
StructuredBuffer<float> _BiomeSecondaryCaveWarpStrengths;
StructuredBuffer<float> _BiomeSecondaryCaveWarpScales;
StructuredBuffer<int>   _BiomeSecondaryCaveWarpRidged;
StructuredBuffer<int>   _BiomeExtraHeightLayerEnabled;
StructuredBuffer<int>   _BiomeExtraHeightOctaves;
StructuredBuffer<float> _BiomeExtraHeightScales;
StructuredBuffer<float> _BiomeExtraHeightLacunarity;
StructuredBuffer<float> _BiomeExtraHeightPersistence;
StructuredBuffer<float> _BiomeExtraHeightImpact;
StructuredBuffer<int>   _BiomeExtraCaveLayerEnabled;
StructuredBuffer<int>   _BiomeExtraCaveOctaves;
StructuredBuffer<float> _BiomeExtraCaveScales;
StructuredBuffer<float> _BiomeExtraCaveLacunarity;
StructuredBuffer<float> _BiomeExtraCavePersistence;
StructuredBuffer<float> _BiomeExtraCaveImpact;
StructuredBuffer<int>   _BiomeCliffLayerEnabled;
StructuredBuffer<float> _BiomeCliffScales;
StructuredBuffer<float> _BiomeCliffImpacts;
StructuredBuffer<float> _BiomeCliffThresholds;
StructuredBuffer<float> _BiomeCliffSharpness;
StructuredBuffer<int>   _BiomePlateauLayerEnabled;
StructuredBuffer<float> _BiomePlateauScales;
StructuredBuffer<float> _BiomePlateauStepHeights;
StructuredBuffer<float> _BiomePlateauStrengths;
StructuredBuffer<float> _BiomePlateauThresholds;
StructuredBuffer<float> _BiomePlateauSharpness;
StructuredBuffer<int>   _BiomeSurfaceCaveMaskEnabled;
StructuredBuffer<float> _BiomeSurfaceCaveMaskScales;
StructuredBuffer<float> _BiomeSurfaceCaveMaskThresholds;
StructuredBuffer<float> _BiomeSurfaceCaveMaskStrengths;
StructuredBuffer<float> _BiomeSurfaceCaveMaskFalloffs;

float _TemperatureNoiseScale;
float _HumidityNoiseScale;
float _RiverNoiseScale;
float _RiverThreshold;
float _RiverDepth;

StructuredBuffer<float> _DensitiesForMC;
StructuredBuffer<float> _GradientDensities;
RWStructuredBuffer<float3> _VertexBuffer;
RWStructuredBuffer<float3> _NormalBuffer;
StructuredBuffer<int> _TriangleTable;
StructuredBuffer<int> _EdgeConnections;
float _SurfaceLevel;
RWStructuredBuffer<uint> _VertexCountBuffer;

RWStructuredBuffer<float> _ModifiedDensities;
float3 _ModificationPosition;
float _ModificationRadius;
float _ModificationStrength;

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
float3 mod289(float3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float4 mod289(float4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float2 mod289(float2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

float4 permute(float4 x) { return mod289(((x*34.0)+1.0)*x); }
float4 taylorInvSqrt(float4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
float3 fade(float3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

float snoise(float2 v)
{
    const float4 C = float4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                           -0.577350269189626,  // -1.0 + 2.0 * C.x
                            0.024390243902439); // 1.0 / 41.0
    float2 i  = floor(v + dot(v, C.yy) );
    float2 x0 = v -   i + dot(i, C.xx);
    float2 i1;
    i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    float3 p_inner_arg = i.y + float3(0.0, i1.y, 1.0);
    float4 p_inner_res = permute(float4(p_inner_arg, 0.0));
    float4 p_outer_arg = p_inner_res + float4(i.x, i.x, i.x, i.x) + float4(0.0, i1.x, 1.0, 0.0);
    float3 p = permute(p_outer_arg).xyz;
    float3 m = max(0.5 - float3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    float3 x = 2.0 * frac(p * C.www) - 1.0;
    float3 h = abs(x) - 0.5;
    float3 ox = floor(x + 0.5);
    float3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    float3 g;
    g.x  = a0.x  * x0.x + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// 3D Simplex noise
float snoise(float3 v)
{
    const float2 C = float2(1.0 / 6.0, 1.0 / 3.0) ;
    const float4 D = float4(0.0, 0.5, 1.0, 2.0);
    float3 i  = floor(v + dot(v, C.yyy) );
    float3 x0 = v - i + dot(i, C.xxx) ;
    float3 g = step(x0.yzx, x0.xyz);
    float3 l = 1.0 - g;
    float3 i1 = min( g.xyz, l.zxy );
    float3 i2 = max( g.xyz, l.zxy );
    float3 x1 = x0 - i1 + C.xxx;
    float3 x2 = x0 - i2 + C.yyy;
    float3 x3 = x0 - D.yyy;
    i = mod289(i);
    float4 p = permute( permute( permute(
                 i.z + float4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + float4(0.0, i1.y, i2.y, 1.0 ))
               + i.x + float4(0.0, i1.x, i2.x, 1.0 ));
    float n_ = 0.142857142857; // 1.0/7.0
    float3 ns = n_ * D.wyz - D.xzx;
    float4 j = p - 49.0 * floor(p * ns.z * ns.z);
    float4 x_ = floor(j * ns.z);
    float4 y_ = floor(j - 7.0 * x_ );
    float4 x = x_ *ns.x + ns.yyyy;
    float4 y = y_ *ns.x + ns.yyyy;
    float4 h = 1.0 - abs(x) - abs(y);
    float4 b0 = float4( x.xy, y.xy );
    float4 b1 = float4( x.zw, y.zw );
    float4 s0 = floor(b0)*2.0 + 1.0;
    float4 s1 = floor(b1)*2.0 + 1.0;
    float4 sh = -step(h, float4(0,0,0,0));
    float4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    float4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    float3 p0 = float3(a0.xy,h.x);
    float3 p1 = float3(a0.zw,h.y);
    float3 p2 = float3(a1.xy,h.z);
    float3 p3 = float3(a1.zw,h.w);
    float4 norm = taylorInvSqrt(float4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    float4 m = max(0.6 - float4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, float4( dot(p0,x0), dot(p1,x1),
                                    dot(p2,x2), dot(p3,x3) ) );
}

static const float2 HEIGHT_WARP_OFFSET = float2(37.21, 17.31);
static const float2 SECONDARY_HEIGHT_WARP_OFFSET_A = float2(81.53, 23.11);
static const float2 SECONDARY_HEIGHT_WARP_OFFSET_B = float2(12.37, 64.29);
static const float3 CAVE_WARP_OFFSET_A = float3(19.13, 7.73, 3.37);
static const float3 CAVE_WARP_OFFSET_B = float3(5.21, 9.18, 12.89);
static const float3 SECONDARY_CAVE_WARP_OFFSET_A = float3(41.12, 3.91, 27.45);
static const float3 SECONDARY_CAVE_WARP_OFFSET_B = float3(13.87, 52.63, 8.14);
static const float3 SECONDARY_CAVE_WARP_OFFSET_C = float3(71.22, 34.55, 19.08);

float applyRidged(float value)
{
    float ridged = 1.0 - abs(value);
    return ridged * 2.0 - 1.0;
}

float fractalNoise(float3 pos, int octaves, float freq, float lacunarity, float persistence)
{
    if (octaves <= 0)
    {
        return 0.0;
    }

    float sum = 0.0;
    float maxAmplitude = 0.0;
    float amplitude = 1.0;
    float currentFreq = freq;

    for (int i = 0; i < octaves; i++)
    {
        sum += snoise(pos * currentFreq) * amplitude;
        maxAmplitude += amplitude;
        currentFreq *= lacunarity;
        amplitude *= persistence;
    }

    if (maxAmplitude > 0.0)
    {
        sum /= maxAmplitude;
    }
    else
    {
        sum = 0.0;
    }

    return sum;
}
float fractalNoise(float2 pos, int octaves, float freq, float lacunarity, float persistence)
{
    if (octaves <= 0)
    {
        return 0.0;
    }

    float sum = 0.0;
    float maxAmplitude = 0.0;
    float amplitude = 1.0;
    float currentFreq = freq;

    for (int i = 0; i < octaves; i++)
    {
        sum += snoise(pos * currentFreq) * amplitude;
        maxAmplitude += amplitude;
        currentFreq *= lacunarity;
        amplitude *= persistence;
    }

    if (maxAmplitude > 0.0)
    {
        sum /= maxAmplitude;
    }
    else
    {
        sum = 0.0;
    }

    return sum;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------

float calculateDensity(float3 worldPos)
{
    float biomeValue = snoise(worldPos.xz * _BiomeNoiseScale);
    float temperatureValue = snoise(worldPos.xz * _TemperatureNoiseScale);
    float humidityValue = snoise(worldPos.xz * _HumidityNoiseScale);

    int currentBiomeIndex = 0;
    for (int i = 0; i < _BiomeCount; i++)
    {
        if (biomeValue >= _BiomeThresholds[i])
        {
            currentBiomeIndex = i;
        }
        else
        {
            break;
        }
    }
    int nextBiomeIndex = min(currentBiomeIndex + 1, _BiomeCount - 1);

    float blendFactor = 0.0;
    if (currentBiomeIndex != nextBiomeIndex)
    {
        float range = _BiomeThresholds[nextBiomeIndex] - _BiomeThresholds[currentBiomeIndex];
        if (range > 0.0001)
        {
            blendFactor = saturate((biomeValue - _BiomeThresholds[currentBiomeIndex]) / range);
        }
    }

    float baseGroundLevel = lerp(_BiomeGroundLevels[currentBiomeIndex], _BiomeGroundLevels[nextBiomeIndex], blendFactor);
    float baseHeightImpact = lerp(_BiomeHeightImpacts[currentBiomeIndex], _BiomeHeightImpacts[nextBiomeIndex], blendFactor);
    float baseHeightScale = lerp(_BiomeHeightScales[currentBiomeIndex], _BiomeHeightScales[nextBiomeIndex], blendFactor);
    float baseCaveImpact = lerp(_BiomeCaveImpacts[currentBiomeIndex], _BiomeCaveImpacts[nextBiomeIndex], blendFactor);
    float baseCaveScale = lerp(_BiomeCaveScales[currentBiomeIndex], _BiomeCaveScales[nextBiomeIndex], blendFactor);
    int finalOctaves = (int)round(lerp(_BiomeOctaves[currentBiomeIndex], _BiomeOctaves[nextBiomeIndex], blendFactor));
    float finalLacunarity = lerp(_BiomeLacunarity[currentBiomeIndex], _BiomeLacunarity[nextBiomeIndex], blendFactor);
    float finalPersistence = lerp(_BiomePersistence[currentBiomeIndex], _BiomePersistence[nextBiomeIndex], blendFactor);

    float heightWarpToggle = lerp((float)_BiomeHeightWarpEnabled[currentBiomeIndex], (float)_BiomeHeightWarpEnabled[nextBiomeIndex], blendFactor);
    float heightWarpStrength = lerp(_BiomeHeightWarpStrengths[currentBiomeIndex], _BiomeHeightWarpStrengths[nextBiomeIndex], blendFactor);
    float heightWarpScale = lerp(_BiomeHeightWarpScales[currentBiomeIndex], _BiomeHeightWarpScales[nextBiomeIndex], blendFactor);
    float heightWarpRidgedToggle = lerp((float)_BiomeHeightWarpRidged[currentBiomeIndex], (float)_BiomeHeightWarpRidged[nextBiomeIndex], blendFactor);
    float secondaryHeightWarpToggle = lerp((float)_BiomeSecondaryHeightWarpEnabled[currentBiomeIndex], (float)_BiomeSecondaryHeightWarpEnabled[nextBiomeIndex], blendFactor);
    float secondaryHeightWarpStrength = lerp(_BiomeSecondaryHeightWarpStrengths[currentBiomeIndex], _BiomeSecondaryHeightWarpStrengths[nextBiomeIndex], blendFactor);
    float secondaryHeightWarpScale = lerp(_BiomeSecondaryHeightWarpScales[currentBiomeIndex], _BiomeSecondaryHeightWarpScales[nextBiomeIndex], blendFactor);
    float secondaryHeightWarpRidgedToggle = lerp((float)_BiomeSecondaryHeightWarpRidged[currentBiomeIndex], (float)_BiomeSecondaryHeightWarpRidged[nextBiomeIndex], blendFactor);
    float caveWarpToggle = lerp((float)_BiomeCaveWarpEnabled[currentBiomeIndex], (float)_BiomeCaveWarpEnabled[nextBiomeIndex], blendFactor);
    float caveWarpStrength = lerp(_BiomeCaveWarpStrengths[currentBiomeIndex], _BiomeCaveWarpStrengths[nextBiomeIndex], blendFactor);
    float caveWarpScale = lerp(_BiomeCaveWarpScales[currentBiomeIndex], _BiomeCaveWarpScales[nextBiomeIndex], blendFactor);
    float caveWarpRidgedToggle = lerp((float)_BiomeCaveWarpRidged[currentBiomeIndex], (float)_BiomeCaveWarpRidged[nextBiomeIndex], blendFactor);
    float secondaryCaveWarpToggle = lerp((float)_BiomeSecondaryCaveWarpEnabled[currentBiomeIndex], (float)_BiomeSecondaryCaveWarpEnabled[nextBiomeIndex], blendFactor);
    float secondaryCaveWarpStrength = lerp(_BiomeSecondaryCaveWarpStrengths[currentBiomeIndex], _BiomeSecondaryCaveWarpStrengths[nextBiomeIndex], blendFactor);
    float secondaryCaveWarpScale = lerp(_BiomeSecondaryCaveWarpScales[currentBiomeIndex], _BiomeSecondaryCaveWarpScales[nextBiomeIndex], blendFactor);
    float secondaryCaveWarpRidgedToggle = lerp((float)_BiomeSecondaryCaveWarpRidged[currentBiomeIndex], (float)_BiomeSecondaryCaveWarpRidged[nextBiomeIndex], blendFactor);
    float extraHeightToggle = lerp((float)_BiomeExtraHeightLayerEnabled[currentBiomeIndex], (float)_BiomeExtraHeightLayerEnabled[nextBiomeIndex], blendFactor);
    int extraHeightOctaves = (int)round(lerp(_BiomeExtraHeightOctaves[currentBiomeIndex], _BiomeExtraHeightOctaves[nextBiomeIndex], blendFactor));
    float extraHeightScale = lerp(_BiomeExtraHeightScales[currentBiomeIndex], _BiomeExtraHeightScales[nextBiomeIndex], blendFactor);
    float extraHeightLacunarity = lerp(_BiomeExtraHeightLacunarity[currentBiomeIndex], _BiomeExtraHeightLacunarity[nextBiomeIndex], blendFactor);
    float extraHeightPersistence = lerp(_BiomeExtraHeightPersistence[currentBiomeIndex], _BiomeExtraHeightPersistence[nextBiomeIndex], blendFactor);
    float extraHeightImpact = lerp(_BiomeExtraHeightImpact[currentBiomeIndex], _BiomeExtraHeightImpact[nextBiomeIndex], blendFactor);
    float extraCaveToggle = lerp((float)_BiomeExtraCaveLayerEnabled[currentBiomeIndex], (float)_BiomeExtraCaveLayerEnabled[nextBiomeIndex], blendFactor);
    int extraCaveOctaves = (int)round(lerp(_BiomeExtraCaveOctaves[currentBiomeIndex], _BiomeExtraCaveOctaves[nextBiomeIndex], blendFactor));
    float extraCaveScale = lerp(_BiomeExtraCaveScales[currentBiomeIndex], _BiomeExtraCaveScales[nextBiomeIndex], blendFactor);
    float extraCaveLacunarity = lerp(_BiomeExtraCaveLacunarity[currentBiomeIndex], _BiomeExtraCaveLacunarity[nextBiomeIndex], blendFactor);
    float extraCavePersistence = lerp(_BiomeExtraCavePersistence[currentBiomeIndex], _BiomeExtraCavePersistence[nextBiomeIndex], blendFactor);
    float extraCaveImpact = lerp(_BiomeExtraCaveImpact[currentBiomeIndex], _BiomeExtraCaveImpact[nextBiomeIndex], blendFactor);
    float cliffToggle = lerp((float)_BiomeCliffLayerEnabled[currentBiomeIndex], (float)_BiomeCliffLayerEnabled[nextBiomeIndex], blendFactor);
    float cliffScale = lerp(_BiomeCliffScales[currentBiomeIndex], _BiomeCliffScales[nextBiomeIndex], blendFactor);
    float cliffImpact = lerp(_BiomeCliffImpacts[currentBiomeIndex], _BiomeCliffImpacts[nextBiomeIndex], blendFactor);
    float cliffThreshold = lerp(_BiomeCliffThresholds[currentBiomeIndex], _BiomeCliffThresholds[nextBiomeIndex], blendFactor);
    float cliffSharpness = lerp(_BiomeCliffSharpness[currentBiomeIndex], _BiomeCliffSharpness[nextBiomeIndex], blendFactor);
    float plateauToggle = lerp((float)_BiomePlateauLayerEnabled[currentBiomeIndex], (float)_BiomePlateauLayerEnabled[nextBiomeIndex], blendFactor);
    float plateauScale = lerp(_BiomePlateauScales[currentBiomeIndex], _BiomePlateauScales[nextBiomeIndex], blendFactor);
    float plateauStepHeight = lerp(_BiomePlateauStepHeights[currentBiomeIndex], _BiomePlateauStepHeights[nextBiomeIndex], blendFactor);
    float plateauStrength = lerp(_BiomePlateauStrengths[currentBiomeIndex], _BiomePlateauStrengths[nextBiomeIndex], blendFactor);
    float plateauThreshold = lerp(_BiomePlateauThresholds[currentBiomeIndex], _BiomePlateauThresholds[nextBiomeIndex], blendFactor);
    float plateauSharpness = lerp(_BiomePlateauSharpness[currentBiomeIndex], _BiomePlateauSharpness[nextBiomeIndex], blendFactor);
    float surfaceCaveMaskToggle = lerp((float)_BiomeSurfaceCaveMaskEnabled[currentBiomeIndex], (float)_BiomeSurfaceCaveMaskEnabled[nextBiomeIndex], blendFactor);
    float surfaceCaveMaskScale = lerp(_BiomeSurfaceCaveMaskScales[currentBiomeIndex], _BiomeSurfaceCaveMaskScales[nextBiomeIndex], blendFactor);
    float surfaceCaveMaskThreshold = lerp(_BiomeSurfaceCaveMaskThresholds[currentBiomeIndex], _BiomeSurfaceCaveMaskThresholds[nextBiomeIndex], blendFactor);
    float surfaceCaveMaskStrength = lerp(_BiomeSurfaceCaveMaskStrengths[currentBiomeIndex], _BiomeSurfaceCaveMaskStrengths[nextBiomeIndex], blendFactor);
    float surfaceCaveMaskFalloff = lerp(_BiomeSurfaceCaveMaskFalloffs[currentBiomeIndex], _BiomeSurfaceCaveMaskFalloffs[nextBiomeIndex], blendFactor);

    float groundLevelModifier = 0.0;
    float heightImpactModifier = 1.0;
    float caveImpactModifier = 1.0;
    if (temperatureValue > 0.6) { heightImpactModifier *= lerp(1.0, 0.3, saturate((temperatureValue - 0.6) / 0.4)); }
    if (humidityValue > 0.5)
    {
        float humidFactor = saturate((humidityValue - 0.5) / 0.5);
        heightImpactModifier *= lerp(1.0, 1.3, humidFactor);
        groundLevelModifier += lerp(0.0, -2.0, humidFactor);
    }
    if (temperatureValue < -0.3 && humidityValue < 0.0)
    {
        caveImpactModifier *= lerp(1.0, 1.5, saturate((-temperatureValue - 0.3) / 0.7) * saturate(-humidityValue));
    }

    float finalGroundLevel = baseGroundLevel + groundLevelModifier;
    float finalHeightImpact = baseHeightImpact * heightImpactModifier;
    float finalCaveImpact = baseCaveImpact * caveImpactModifier;

    float2 heightSamplePos = worldPos.xz;
    bool useHeightWarp = (heightWarpToggle > 0.5) && abs(heightWarpStrength) > 0.0001 && abs(heightWarpScale) > 0.0001;
    bool heightWarpUseRidged = heightWarpRidgedToggle > 0.5;
    if (useHeightWarp)
    {
        float2 warpInput = heightSamplePos * heightWarpScale;
        float warpX = snoise(warpInput);
        float warpZ = snoise(warpInput + HEIGHT_WARP_OFFSET);
        if (heightWarpUseRidged)
        {
            warpX = applyRidged(warpX);
            warpZ = applyRidged(warpZ);
        }
        heightSamplePos += float2(warpX, warpZ) * heightWarpStrength;
    }

    bool useSecondaryHeightWarp = (secondaryHeightWarpToggle > 0.5) && abs(secondaryHeightWarpStrength) > 0.0001 && abs(secondaryHeightWarpScale) > 0.0001;
    bool secondaryHeightWarpUseRidged = secondaryHeightWarpRidgedToggle > 0.5;
    if (useSecondaryHeightWarp)
    {
        float2 warpInput = heightSamplePos * secondaryHeightWarpScale;
        float warpX = snoise(warpInput + SECONDARY_HEIGHT_WARP_OFFSET_A);
        float warpZ = snoise(warpInput + SECONDARY_HEIGHT_WARP_OFFSET_B);
        if (secondaryHeightWarpUseRidged)
        {
            warpX = applyRidged(warpX);
            warpZ = applyRidged(warpZ);
        }
        heightSamplePos += float2(warpX, warpZ) * secondaryHeightWarpStrength;
    }

    float sum2D = fractalNoise(heightSamplePos, finalOctaves, baseHeightScale, finalLacunarity, finalPersistence);
    float heightContribution = sum2D * finalHeightImpact;

    bool useExtraHeightLayer = (extraHeightToggle > 0.5) && extraHeightOctaves > 0 && abs(extraHeightImpact) > 0.0001 && abs(extraHeightScale) > 0.0001;
    if (useExtraHeightLayer)
    {
        float extraHeightNoise = fractalNoise(heightSamplePos, extraHeightOctaves, extraHeightScale, extraHeightLacunarity, extraHeightPersistence);
        heightContribution += extraHeightNoise * extraHeightImpact;
    }

    bool useCliffLayer = (cliffToggle > 0.5) && abs(cliffImpact) > 0.0001 && abs(cliffScale) > 0.0001;
    if (useCliffLayer)
    {
        float cliffNoise = snoise(heightSamplePos * cliffScale);
        float ridgedCliff = 1.0 - abs(cliffNoise);
        float denom = max(1.0 - cliffThreshold, 0.0001);
        float normalized = saturate((ridgedCliff - cliffThreshold) / denom);
        float sharpness = max(cliffSharpness, 0.0001);
        float mask = pow(normalized, sharpness);
        heightContribution -= mask * cliffImpact;
    }

    bool usePlateauLayer = (plateauToggle > 0.5) && plateauStepHeight > 0.0001 && abs(plateauScale) > 0.0001 && abs(plateauStrength) > 0.0001;
    if (usePlateauLayer)
    {
        float plateauNoise = snoise(heightSamplePos * plateauScale);
        float denom = max(1.0 - plateauThreshold, 0.0001);
        float normalized = saturate((plateauNoise - plateauThreshold) / denom);
        float sharpness = max(plateauSharpness, 0.0001);
        float mask = pow(normalized, sharpness);
        float plateauStrengthClamped = saturate(plateauStrength);
        float target = round(heightContribution / plateauStepHeight) * plateauStepHeight;
        heightContribution = lerp(heightContribution, target, mask * plateauStrengthClamped);
    }

    float surfaceHeight = finalGroundLevel + heightContribution;
    float surfaceDensity = worldPos.y - surfaceHeight;
    float finalDensity = surfaceDensity;

    float3 caveSamplePos = worldPos;
    bool useCaveWarp = (caveWarpToggle > 0.5) && abs(caveWarpStrength) > 0.0001 && abs(caveWarpScale) > 0.0001;
    bool caveWarpUseRidged = caveWarpRidgedToggle > 0.5;
    if (useCaveWarp)
    {
        float3 warpInput = caveSamplePos * caveWarpScale;
        float warpX = snoise(warpInput);
        float warpY = snoise(warpInput + CAVE_WARP_OFFSET_A);
        float warpZ = snoise(warpInput + CAVE_WARP_OFFSET_B);
        if (caveWarpUseRidged)
        {
            warpX = applyRidged(warpX);
            warpY = applyRidged(warpY);
            warpZ = applyRidged(warpZ);
        }
        caveSamplePos += float3(warpX, warpY, warpZ) * caveWarpStrength;
    }

    bool useSecondaryCaveWarp = (secondaryCaveWarpToggle > 0.5) && abs(secondaryCaveWarpStrength) > 0.0001 && abs(secondaryCaveWarpScale) > 0.0001;
    bool secondaryCaveWarpUseRidged = secondaryCaveWarpRidgedToggle > 0.5;
    if (useSecondaryCaveWarp)
    {
        float3 warpInput = caveSamplePos * secondaryCaveWarpScale;
        float warpX = snoise(warpInput + SECONDARY_CAVE_WARP_OFFSET_A);
        float warpY = snoise(warpInput + SECONDARY_CAVE_WARP_OFFSET_B);
        float warpZ = snoise(warpInput + SECONDARY_CAVE_WARP_OFFSET_C);
        if (secondaryCaveWarpUseRidged)
        {
            warpX = applyRidged(warpX);
            warpY = applyRidged(warpY);
            warpZ = applyRidged(warpZ);
        }
        caveSamplePos += float3(warpX, warpY, warpZ) * secondaryCaveWarpStrength;
    }

    if (surfaceDensity < 0.0)
    {
        float depthFactor = min(-surfaceDensity / 10.0, 1.0);
        float sum3D = fractalNoise(caveSamplePos, finalOctaves, baseCaveScale, finalLacunarity, finalPersistence);
        finalDensity -= sum3D * finalCaveImpact * depthFactor;

        bool useExtraCaveLayer = (extraCaveToggle > 0.5) && extraCaveOctaves > 0 && abs(extraCaveImpact) > 0.0001 && abs(extraCaveScale) > 0.0001;
        if (useExtraCaveLayer)
        {
            float extraCaveNoise = fractalNoise(caveSamplePos, extraCaveOctaves, extraCaveScale, extraCaveLacunarity, extraCavePersistence);
            finalDensity -= extraCaveNoise * extraCaveImpact * depthFactor;
        }
    }

    bool useSurfaceCaveMask = (surfaceCaveMaskToggle > 0.5) && abs(surfaceCaveMaskStrength) > 0.0001 && abs(surfaceCaveMaskScale) > 0.0001 && surfaceCaveMaskFalloff > 0.0001;
    if (useSurfaceCaveMask)
    {
        float maskNoise = snoise(worldPos.xz * surfaceCaveMaskScale);
        float denom = max(1.0 - surfaceCaveMaskThreshold, 0.0001);
        float mask = saturate((maskNoise - surfaceCaveMaskThreshold) / denom);
        float depthAttenuation = saturate(1.0 - abs(surfaceDensity) / surfaceCaveMaskFalloff);
        finalDensity -= surfaceCaveMaskStrength * mask * depthAttenuation;
    }

    float riverNoiseValue = snoise(worldPos.xz * _RiverNoiseScale);
    float riverProximity = abs(riverNoiseValue);
    if (riverProximity < _RiverThreshold)
    {
        if (surfaceDensity < 0.0 && surfaceDensity > -20.0)
        {
            finalDensity -= _RiverDepth * (1.0 - smoothstep(0, _RiverThreshold, riverProximity));
        }
    }

    return finalDensity;
}

[numthreads(8,8,8)]
void GenerateVoxelData(uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)_ChunkSize.x || id.y > (uint)_ChunkSize.y || id.z > (uint)_ChunkSize.z) return;
    
    uint index = id.x + id.y * (_ChunkSize.x + 1) + id.z * (_ChunkSize.x + 1) * (_ChunkSize.y + 1);
    
    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    float3 worldPos = _ChunkWorldOrigin + float3(id.x, id.y, id.z) * adjustedVoxelSize;
    
    float density = calculateDensity(worldPos);
    _DensityValues[index] = clamp(density, -1.0, 1.0);
}


//-------------------------------------------------------------------------------------
// Marching Cubes
//-------------------------------------------------------------------------------------

static const int3 cubeCorners[8] = {
    int3(0, 0, 0), int3(1, 0, 0), int3(1, 0, 1), int3(0, 0, 1),
    int3(0, 1, 0), int3(1, 1, 0), int3(1, 1, 1), int3(0, 1, 1)
};

static const int GRADIENT_PADDING = 3;
static const int GRADIENT_OFFSET = 1;

uint getDensityIndex(uint3 coords, int3 chunkSize)
{
    return coords.x + coords.y * (chunkSize.x + 1) + coords.z * (chunkSize.x + 1) * (chunkSize.y + 1);
}

uint getGradientDensityIndex(int3 coords, int3 chunkSize)
{
    int width = chunkSize.x + GRADIENT_PADDING;
    int height = chunkSize.y + GRADIENT_PADDING;
    int x = coords.x + GRADIENT_OFFSET;
    int y = coords.y + GRADIENT_OFFSET;
    int z = coords.z + GRADIENT_OFFSET;
    return (uint)(x + y * width + z * width * height);
}

float getGradientDensity(int3 coords)
{
    return _GradientDensities[getGradientDensityIndex(coords, _ChunkSize)];
}

float3 calculateDensityGradient(int3 coords)
{
    float dx = getGradientDensity(coords + int3(1, 0, 0)) - getGradientDensity(coords - int3(1, 0, 0));
    float dy = getGradientDensity(coords + int3(0, 1, 0)) - getGradientDensity(coords - int3(0, 1, 0));
    float dz = getGradientDensity(coords + int3(0, 0, 1)) - getGradientDensity(coords - int3(0, 0, 1));
    return float3(dx, dy, dz) * 0.5;
}

float3 normalizeGradient(float3 gradient)
{
    float lengthSq = dot(gradient, gradient);
    if (lengthSq > 1e-12f)
    {
        return gradient * rsqrt(lengthSq);
    }
    return float3(0.0, 1.0, 0.0);
}

float sampleCornerDensity(int cornerIndex, int3 baseCoords)
{
    int3 corner = cubeCorners[cornerIndex];
    int3 densityCoords = baseCoords + corner;
    uint3 cornerPos = uint3(densityCoords.x, densityCoords.y, densityCoords.z);
    return _DensitiesForMC[getDensityIndex(cornerPos, _ChunkSize)];
}

float3 sampleCornerGradient(int cornerIndex, int3 baseCoords)
{
    int3 corner = cubeCorners[cornerIndex];
    return calculateDensityGradient(baseCoords + corner);
}

float3 vertexInterpolation(float3 posA, float3 posB, float valA, float valB, out float t)
{
    if (abs(valA - valB) < 0.00001)
    {
        t = 0.0;
        return posA;
    }

    t = (_SurfaceLevel - valA) / (valB - valA);
    return posA + (posB - posA) * t;
}

[numthreads(8,8,8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_ChunkSize.x || id.y >= (uint)_ChunkSize.y || id.z >= (uint)_ChunkSize.z) return;

    float cornerDensities[8];
    float3 cornerGradients[8];
    float3 cornerPositions[8];
    int3 baseCoords = int3(id.x, id.y, id.z);
    float3 cellBase = float3(id.x, id.y, id.z);
    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    for (int i = 0; i < 8; i++)
    {
        int3 corner = cubeCorners[i];
        cornerDensities[i] = sampleCornerDensity(i, baseCoords);
        cornerGradients[i] = sampleCornerGradient(i, baseCoords);
        float3 cornerOffset = float3(corner.x, corner.y, corner.z);
        cornerPositions[i] = (cellBase + cornerOffset) * adjustedVoxelSize;
    }

    int cubeIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        if (cornerDensities[i] < _SurfaceLevel) cubeIndex |= (1 << i);
    }
    
    if (cubeIndex == 0 || cubeIndex == 255) return;
    
    for (int i = 0; _TriangleTable[cubeIndex * 16 + i] != -1; i += 3)
    {
        int edge1 = _TriangleTable[cubeIndex * 16 + i];
        int edge2 = _TriangleTable[cubeIndex * 16 + i + 1];
        int edge3 = _TriangleTable[cubeIndex * 16 + i + 2];

        int cornerIdx1A = _EdgeConnections[edge1 * 2];
        int cornerIdx1B = _EdgeConnections[edge1 * 2 + 1];
        int cornerIdx2A = _EdgeConnections[edge2 * 2];
        int cornerIdx2B = _EdgeConnections[edge2 * 2 + 1];
        int cornerIdx3A = _EdgeConnections[edge3 * 2];
        int cornerIdx3B = _EdgeConnections[edge3 * 2 + 1];

        float t1;
        float3 v1 = vertexInterpolation(
            cornerPositions[cornerIdx1A],
            cornerPositions[cornerIdx1B],
            cornerDensities[cornerIdx1A],
            cornerDensities[cornerIdx1B],
            t1
        );
        float3 n1 = normalizeGradient(lerp(cornerGradients[cornerIdx1A], cornerGradients[cornerIdx1B], t1));

        float t2;
        float3 v2 = vertexInterpolation(
            cornerPositions[cornerIdx2A],
            cornerPositions[cornerIdx2B],
            cornerDensities[cornerIdx2A],
            cornerDensities[cornerIdx2B],
            t2
        );
        float3 n2 = normalizeGradient(lerp(cornerGradients[cornerIdx2A], cornerGradients[cornerIdx2B], t2));

        float t3;
        float3 v3 = vertexInterpolation(
            cornerPositions[cornerIdx3A],
            cornerPositions[cornerIdx3B],
            cornerDensities[cornerIdx3A],
            cornerDensities[cornerIdx3B],
            t3
        );
        float3 n3 = normalizeGradient(lerp(cornerGradients[cornerIdx3A], cornerGradients[cornerIdx3B], t3));

        uint baseIndex;
        InterlockedAdd(_VertexCountBuffer[0], 3, baseIndex);

        _VertexBuffer[baseIndex + 0] = v1;
        _NormalBuffer[baseIndex + 0] = n1;
        _VertexBuffer[baseIndex + 1] = v2;
        _NormalBuffer[baseIndex + 1] = n2;
        _VertexBuffer[baseIndex + 2] = v3;
        _NormalBuffer[baseIndex + 2] = n3;
    }
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------

[numthreads(8,8,8)]
void ModifyDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)_ChunkSize.x || id.y > (uint)_ChunkSize.y || id.z > (uint)_ChunkSize.z) return;

    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    float3 voxelWorldPos = _ChunkWorldOrigin + float3(id.x, id.y, id.z) * adjustedVoxelSize;

    float dist = distance(voxelWorldPos, _ModificationPosition);

    if (dist <= _ModificationRadius)
    {
        uint index = getDensityIndex(id, _ChunkSize);
        float modificationAmount = _ModificationStrength * (1.0 - smoothstep(0.0, _ModificationRadius, dist));
        _ModifiedDensities[index] = clamp(_ModifiedDensities[index] - modificationAmount, -1.0, 1.0);
    }
}