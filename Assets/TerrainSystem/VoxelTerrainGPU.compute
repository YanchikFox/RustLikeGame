// VoxelTerrainGPU.compute
// GPU-based voxel terrain generation and modification

#pragma kernel GenerateVoxelData
#pragma kernel MarchingCubes
#pragma kernel ModifyDensity

RWStructuredBuffer<float> _DensityValues;
float3 _ChunkWorldOrigin;
int3 _ChunkSize;
float _VoxelSize;
int _LODLevel;

float _BiomeNoiseScale;
float _BiomeBlendRange;
int _BiomeCount;
StructuredBuffer<float> _BiomeThresholds;
StructuredBuffer<float> _BiomeGroundLevels;
StructuredBuffer<float> _BiomeHeightImpacts;
StructuredBuffer<float> _BiomeHeightScales;
StructuredBuffer<float> _BiomeCaveImpacts;
StructuredBuffer<float> _BiomeCaveScales;
StructuredBuffer<int>   _BiomeOctaves;
StructuredBuffer<float> _BiomeLacunarity;
StructuredBuffer<float> _BiomePersistence;

float _TemperatureNoiseScale;
float _HumidityNoiseScale;
float _RiverNoiseScale;
float _RiverThreshold;
float _RiverDepth;

StructuredBuffer<float> _DensitiesForMC;
StructuredBuffer<float> _GradientDensities;
RWStructuredBuffer<float3> _VertexBuffer;
RWStructuredBuffer<float3> _NormalBuffer;
StructuredBuffer<int> _TriangleTable;
StructuredBuffer<int> _EdgeConnections;
float _SurfaceLevel;
RWStructuredBuffer<uint> _VertexCountBuffer;

RWStructuredBuffer<float> _ModifiedDensities;
float3 _ModificationPosition;
float _ModificationRadius;
float _ModificationStrength;

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
float3 mod289(float3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float4 mod289(float4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float2 mod289(float2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

float4 permute(float4 x) { return mod289(((x*34.0)+1.0)*x); }
float4 taylorInvSqrt(float4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
float3 fade(float3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

float snoise(float2 v)
{
    const float4 C = float4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                           -0.577350269189626,  // -1.0 + 2.0 * C.x
                            0.024390243902439); // 1.0 / 41.0
    float2 i  = floor(v + dot(v, C.yy) );
    float2 x0 = v -   i + dot(i, C.xx);
    float2 i1;
    i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    float3 p_inner_arg = i.y + float3(0.0, i1.y, 1.0);
    float4 p_inner_res = permute(float4(p_inner_arg, 0.0));
    float4 p_outer_arg = p_inner_res + float4(i.x, i.x, i.x, i.x) + float4(0.0, i1.x, 1.0, 0.0);
    float3 p = permute(p_outer_arg).xyz;
    float3 m = max(0.5 - float3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    float3 x = 2.0 * frac(p * C.www) - 1.0;
    float3 h = abs(x) - 0.5;
    float3 ox = floor(x + 0.5);
    float3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    float3 g;
    g.x  = a0.x  * x0.x + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// 3D Simplex noise
float snoise(float3 v)
{
    const float2 C = float2(1.0 / 6.0, 1.0 / 3.0) ;
    const float4 D = float4(0.0, 0.5, 1.0, 2.0);
    float3 i  = floor(v + dot(v, C.yyy) );
    float3 x0 = v - i + dot(i, C.xxx) ;
    float3 g = step(x0.yzx, x0.xyz);
    float3 l = 1.0 - g;
    float3 i1 = min( g.xyz, l.zxy );
    float3 i2 = max( g.xyz, l.zxy );
    float3 x1 = x0 - i1 + C.xxx;
    float3 x2 = x0 - i2 + C.yyy;
    float3 x3 = x0 - D.yyy;
    i = mod289(i);
    float4 p = permute( permute( permute(
                 i.z + float4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + float4(0.0, i1.y, i2.y, 1.0 ))
               + i.x + float4(0.0, i1.x, i2.x, 1.0 ));
    float n_ = 0.142857142857; // 1.0/7.0
    float3 ns = n_ * D.wyz - D.xzx;
    float4 j = p - 49.0 * floor(p * ns.z * ns.z);
    float4 x_ = floor(j * ns.z);
    float4 y_ = floor(j - 7.0 * x_ );
    float4 x = x_ *ns.x + ns.yyyy;
    float4 y = y_ *ns.x + ns.yyyy;
    float4 h = 1.0 - abs(x) - abs(y);
    float4 b0 = float4( x.xy, y.xy );
    float4 b1 = float4( x.zw, y.zw );
    float4 s0 = floor(b0)*2.0 + 1.0;
    float4 s1 = floor(b1)*2.0 + 1.0;
    float4 sh = -step(h, float4(0,0,0,0));
    float4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    float4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    float3 p0 = float3(a0.xy,h.x);
    float3 p1 = float3(a0.zw,h.y);
    float3 p2 = float3(a1.xy,h.z);
    float3 p3 = float3(a1.zw,h.w);
    float4 norm = taylorInvSqrt(float4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    float4 m = max(0.6 - float4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, float4( dot(p0,x0), dot(p1,x1),
                                    dot(p2,x2), dot(p3,x3) ) );
}

float fractalNoise(float3 pos, int octaves, float freq, float lacunarity, float persistence)
{
    float sum = 0.0;
    float maxAmplitude = 0.0;
    float amplitude = 1.0;

    for (int i = 0; i < octaves; i++)
    {
        sum += snoise(pos * freq) * amplitude;
        maxAmplitude += amplitude;
        freq *= lacunarity;
        amplitude *= persistence;
    }
    return sum / maxAmplitude;
}
float fractalNoise(float2 pos, int octaves, float freq, float lacunarity, float persistence)
{
    float sum = 0.0;
    float maxAmplitude = 0.0;
    float amplitude = 1.0;

    for (int i = 0; i < octaves; i++)
    {
        sum += snoise(pos * freq) * amplitude;
        maxAmplitude += amplitude;
        freq *= lacunarity;
        amplitude *= persistence;
    }
    return sum / maxAmplitude;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------

float calculateDensity(float3 worldPos)
{
    float biomeValue = snoise(worldPos.xz * _BiomeNoiseScale);
    float temperatureValue = snoise(worldPos.xz * _TemperatureNoiseScale);
    float humidityValue = snoise(worldPos.xz * _HumidityNoiseScale);

    int currentBiomeIndex = 0;
    for (int i = 0; i < _BiomeCount; i++)
    {
        if (biomeValue >= _BiomeThresholds[i]) { currentBiomeIndex = i; } else { break; }
    }
    int nextBiomeIndex = min(currentBiomeIndex + 1, _BiomeCount - 1);

    float blendFactor = 0.0;
    if (currentBiomeIndex != nextBiomeIndex)
    {
        float range = _BiomeThresholds[nextBiomeIndex] - _BiomeThresholds[currentBiomeIndex];
        if (range > 0.0001) { blendFactor = saturate((biomeValue - _BiomeThresholds[currentBiomeIndex]) / range); }
    }

    float baseGroundLevel = lerp(_BiomeGroundLevels[currentBiomeIndex], _BiomeGroundLevels[nextBiomeIndex], blendFactor);
    float baseHeightImpact = lerp(_BiomeHeightImpacts[currentBiomeIndex], _BiomeHeightImpacts[nextBiomeIndex], blendFactor);
    float baseHeightScale = lerp(_BiomeHeightScales[currentBiomeIndex], _BiomeHeightScales[nextBiomeIndex], blendFactor);
    float baseCaveImpact = lerp(_BiomeCaveImpacts[currentBiomeIndex], _BiomeCaveImpacts[nextBiomeIndex], blendFactor);
    float baseCaveScale = lerp(_BiomeCaveScales[currentBiomeIndex], _BiomeCaveScales[nextBiomeIndex], blendFactor);
    int finalOctaves = (int)round(lerp(_BiomeOctaves[currentBiomeIndex], _BiomeOctaves[nextBiomeIndex], blendFactor));
    float finalLacunarity = lerp(_BiomeLacunarity[currentBiomeIndex], _BiomeLacunarity[nextBiomeIndex], blendFactor);
    float finalPersistence = lerp(_BiomePersistence[currentBiomeIndex], _BiomePersistence[nextBiomeIndex], blendFactor);

    float groundLevelModifier = 0.0;
    float heightImpactModifier = 1.0;
    float caveImpactModifier = 1.0;
    if (temperatureValue > 0.6) { heightImpactModifier *= lerp(1.0, 0.3, saturate((temperatureValue - 0.6) / 0.4)); }
    if (humidityValue > 0.5)
    {
        float humidFactor = saturate((humidityValue - 0.5) / 0.5);
        heightImpactModifier *= lerp(1.0, 1.3, humidFactor);
        groundLevelModifier += lerp(0.0, -2.0, humidFactor);
    }
    if (temperatureValue < -0.3 && humidityValue < 0.0) { caveImpactModifier *= lerp(1.0, 1.5, saturate((-temperatureValue - 0.3) / 0.7) * saturate(-humidityValue)); }

    float finalGroundLevel = baseGroundLevel + groundLevelModifier;
    float finalHeightImpact = baseHeightImpact * heightImpactModifier;
    float finalCaveImpact = baseCaveImpact * caveImpactModifier;

    float sum2D = fractalNoise(worldPos.xz, finalOctaves, baseHeightScale, finalLacunarity, finalPersistence);
    float surfaceHeight = finalGroundLevel + (sum2D * finalHeightImpact);
    float surfaceDensity = worldPos.y - surfaceHeight;
    float finalDensity = surfaceDensity;
    
    if (surfaceDensity < 0)
    {
        float sum3D = fractalNoise(worldPos, finalOctaves, baseCaveScale, finalLacunarity, finalPersistence);
        float depthFactor = min(-surfaceDensity / 10.0, 1.0);
        finalDensity -= (sum3D * finalCaveImpact * depthFactor);
    }

    float riverNoiseValue = snoise(worldPos.xz * _RiverNoiseScale);
    float riverProximity = abs(riverNoiseValue);
    if (riverProximity < _RiverThreshold)
    {
        if (surfaceDensity < 0 && surfaceDensity > -20)
        {
            finalDensity -= _RiverDepth * (1.0 - smoothstep(0, _RiverThreshold, riverProximity));
        }
    }
    return finalDensity;
}

[numthreads(8,8,8)]
void GenerateVoxelData(uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)_ChunkSize.x || id.y > (uint)_ChunkSize.y || id.z > (uint)_ChunkSize.z) return;
    
    uint index = id.x + id.y * (_ChunkSize.x + 1) + id.z * (_ChunkSize.x + 1) * (_ChunkSize.y + 1);
    
    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    float3 worldPos = _ChunkWorldOrigin + float3(id.x, id.y, id.z) * adjustedVoxelSize;
    
    float density = calculateDensity(worldPos);
    _DensityValues[index] = clamp(density, -1.0, 1.0);
}


//-------------------------------------------------------------------------------------
// Marching Cubes
//-------------------------------------------------------------------------------------

static const int3 cubeCorners[8] = {
    int3(0, 0, 0), int3(1, 0, 0), int3(1, 0, 1), int3(0, 0, 1),
    int3(0, 1, 0), int3(1, 1, 0), int3(1, 1, 1), int3(0, 1, 1)
};

static const int GRADIENT_PADDING = 3;
static const int GRADIENT_OFFSET = 1;

uint getDensityIndex(uint3 coords, int3 chunkSize)
{
    return coords.x + coords.y * (chunkSize.x + 1) + coords.z * (chunkSize.x + 1) * (chunkSize.y + 1);
}

uint getGradientDensityIndex(int3 coords, int3 chunkSize)
{
    int width = chunkSize.x + GRADIENT_PADDING;
    int height = chunkSize.y + GRADIENT_PADDING;
    int x = coords.x + GRADIENT_OFFSET;
    int y = coords.y + GRADIENT_OFFSET;
    int z = coords.z + GRADIENT_OFFSET;
    return (uint)(x + y * width + z * width * height);
}

float getGradientDensity(int3 coords)
{
    return _GradientDensities[getGradientDensityIndex(coords, _ChunkSize)];
}

float3 calculateDensityGradient(int3 coords)
{
    float dx = getGradientDensity(coords + int3(1, 0, 0)) - getGradientDensity(coords - int3(1, 0, 0));
    float dy = getGradientDensity(coords + int3(0, 1, 0)) - getGradientDensity(coords - int3(0, 1, 0));
    float dz = getGradientDensity(coords + int3(0, 0, 1)) - getGradientDensity(coords - int3(0, 0, 1));
    return float3(dx, dy, dz) * 0.5;
}

float3 normalizeGradient(float3 gradient)
{
    float lengthSq = dot(gradient, gradient);
    if (lengthSq > 1e-12f)
    {
        return gradient * rsqrt(lengthSq);
    }
    return float3(0.0, 1.0, 0.0);
}

float3 vertexInterpolation(float3 posA, float3 posB, float valA, float valB, out float t)
{
    if (abs(valA - valB) < 0.00001)
    {
        t = 0.0;
        return posA;
    }

    t = (_SurfaceLevel - valA) / (valB - valA);
    return posA + (posB - posA) * t;
}

[numthreads(8,8,8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_ChunkSize.x || id.y >= (uint)_ChunkSize.y || id.z >= (uint)_ChunkSize.z) return;

    float cornerDensities[8];
    float3 cornerGradients[8];
    float3 cornerPositions[8];
    int3 baseCoords = int3(id.x, id.y, id.z);
    float3 cellBase = float3(id.x, id.y, id.z);
    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    for (int i = 0; i < 8; i++)
    {
        int3 corner = cubeCorners[i];
        int3 densityCoords = baseCoords + corner;
        uint3 cornerPos = uint3(densityCoords.x, densityCoords.y, densityCoords.z);
        cornerDensities[i] = _DensitiesForMC[getDensityIndex(cornerPos, _ChunkSize)];
        cornerGradients[i] = calculateDensityGradient(densityCoords);
        float3 cornerOffset = float3(corner.x, corner.y, corner.z);
        cornerPositions[i] = (cellBase + cornerOffset) * adjustedVoxelSize;
    }

    int cubeIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        if (cornerDensities[i] < _SurfaceLevel) cubeIndex |= (1 << i);
    }
    
    if (cubeIndex == 0 || cubeIndex == 255) return;
    
    for (int i = 0; _TriangleTable[cubeIndex * 16 + i] != -1; i += 3)
    {
        int edge1 = _TriangleTable[cubeIndex * 16 + i];
        int edge2 = _TriangleTable[cubeIndex * 16 + i + 1];
        int edge3 = _TriangleTable[cubeIndex * 16 + i + 2];

        int cornerIdx1A = _EdgeConnections[edge1 * 2];
        int cornerIdx1B = _EdgeConnections[edge1 * 2 + 1];
        int cornerIdx2A = _EdgeConnections[edge2 * 2];
        int cornerIdx2B = _EdgeConnections[edge2 * 2 + 1];
        int cornerIdx3A = _EdgeConnections[edge3 * 2];
        int cornerIdx3B = _EdgeConnections[edge3 * 2 + 1];

        float t1;
        float3 v1 = vertexInterpolation(
            cornerPositions[cornerIdx1A],
            cornerPositions[cornerIdx1B],
            cornerDensities[cornerIdx1A],
            cornerDensities[cornerIdx1B],
            t1
        );
        float3 n1 = normalizeGradient(lerp(cornerGradients[cornerIdx1A], cornerGradients[cornerIdx1B], t1));

        float t2;
        float3 v2 = vertexInterpolation(
            cornerPositions[cornerIdx2A],
            cornerPositions[cornerIdx2B],
            cornerDensities[cornerIdx2A],
            cornerDensities[cornerIdx2B],
            t2
        );
        float3 n2 = normalizeGradient(lerp(cornerGradients[cornerIdx2A], cornerGradients[cornerIdx2B], t2));

        float t3;
        float3 v3 = vertexInterpolation(
            cornerPositions[cornerIdx3A],
            cornerPositions[cornerIdx3B],
            cornerDensities[cornerIdx3A],
            cornerDensities[cornerIdx3B],
            t3
        );
        float3 n3 = normalizeGradient(lerp(cornerGradients[cornerIdx3A], cornerGradients[cornerIdx3B], t3));

        uint baseIndex;
        InterlockedAdd(_VertexCountBuffer[0], 3, baseIndex);

        _VertexBuffer[baseIndex + 0] = v1;
        _NormalBuffer[baseIndex + 0] = n1;
        _VertexBuffer[baseIndex + 1] = v2;
        _NormalBuffer[baseIndex + 1] = n2;
        _VertexBuffer[baseIndex + 2] = v3;
        _NormalBuffer[baseIndex + 2] = n3;
    }
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------

[numthreads(8,8,8)]
void ModifyDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x > (uint)_ChunkSize.x || id.y > (uint)_ChunkSize.y || id.z > (uint)_ChunkSize.z) return;

    float adjustedVoxelSize = _VoxelSize * pow(2, _LODLevel);
    float3 voxelWorldPos = _ChunkWorldOrigin + float3(id.x, id.y, id.z) * adjustedVoxelSize;

    float dist = distance(voxelWorldPos, _ModificationPosition);

    if (dist <= _ModificationRadius)
    {
        uint index = getDensityIndex(id, _ChunkSize);
        float modificationAmount = _ModificationStrength * (1.0 - smoothstep(0.0, _ModificationRadius, dist));
        _ModifiedDensities[index] = clamp(_ModifiedDensities[index] - modificationAmount, -1.0, 1.0);
    }
}